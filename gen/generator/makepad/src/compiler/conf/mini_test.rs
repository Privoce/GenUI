use makepad_widgets :: * ; use gen_components :: * ; use crate :: components :: hello ::*; live_design ! { use link :: widgets :: * ; use link :: gen_components :: * ; use link :: shaders :: * ; use crate :: components :: hello ::*; pub Home = { { Home } } { item_ptr0 : < GLabel > { } , padding : 12.0 , height : Fit , align : { x : 0.5 , y : 0.5 , } , flow : Down , spacing : 16.0 , header = < Hello > { height : 40.0 , } my_btn = < GButton > { theme : Error , slot : < GLabel > { font_size : 12.0 , text : "Click Me!" , } } } } # [derive (Live , Widget)] pub struct Home { # [deref] pub deref_widget : GView , # [live] num : u32 , # [live] lbs : Vec < String > , # [live] item_ptr0 : Option < LivePtr > , # [rust] twb_poll : TwoWayBindingPoll } impl Home { fn get_num (& self) -> u32 { self . num . clone () } fn set_num (& mut self , cx : & mut Cx , value : u32) -> () { self . num = value . clone () ; } fn get_lbs (& self) -> Vec < String > { self . lbs . clone () } fn set_lbs (& mut self , cx : & mut Cx , value : Vec < String >) -> () { let widget = self . hello (id ! (header)) ; widget . set_list (cx , value . clone ()) ; self . sugar_for_lbs (cx , & value) ; self . lbs = value . clone () ; } fn sugar_for_lbs (& mut self , cx : & mut Cx , value : & Vec < String >) -> () { let len_lbs = self . lbs . len () ; if len_lbs > 0 && self . children . len () > 1usize { for _ in 1usize .. (1usize + len_lbs) { self . children . remove (1usize) ; } } for (index , item) in value . iter () . enumerate () { let item = item . clone () ; let widget_ref = WidgetRef :: new_from_ptr (cx , self . item_ptr0) ; let widget_target = widget_ref . as_glabel () ; widget_target . set_text (cx , item) ; self . children . insert (1usize + index , (LiveId (index as u64) , widget_ref)) ; } self . redraw (cx) ; } # [allow (unused_variables)] fn click_btn (& mut self , cx : & mut Cx) { let mut list = self . hello (id ! (header)) . get_list () ; list . push ("Rust" . to_string ()) ; let header = self . hello (id ! (header)) ; self . lbs = list . clone () ; header . set_list (cx , list) ; } } # [allow (unused)] impl HomeRef { pub fn get_num (& self) -> u32 { self . getter (| c_ref | c_ref . num . clone ()) } pub fn set_num (& self , cx : & mut Cx , value : u32) -> () { self . setter (cx , | c_ref , cx | { c_ref . set_num (cx , value) ; }) ; } pub fn get_lbs (& self) -> Vec < String > { self . getter (| c_ref | c_ref . lbs . clone ()) } pub fn set_lbs (& self , cx : & mut Cx , value : Vec < String >) -> () { self . setter (cx , | c_ref , cx | { c_ref . set_lbs (cx , value) ; }) ; } fn setter < F > (& self , cx : & mut Cx , f : F) -> () where F : FnOnce (& mut std :: cell :: RefMut < '_ , Home > , & mut Cx) , { if let Some (mut c_ref) = self . borrow_mut () { f (& mut c_ref , cx) ; } } fn getter < T , F > (& self , f : F) -> T where F : Fn (& std :: cell :: Ref < '_ , Home >) -> T , T : Default , { if let Some (c_ref) = self . borrow () { f (& c_ref) } else { T :: default () } } } impl Widget for Home { # [allow (unused_variables)] fn draw_walk (& mut self , cx : & mut Cx2d , scope : & mut Scope , walk : Walk) -> DrawStep { self . deref_widget . draw_walk (cx , scope , walk) } # [allow (unused_variables)] fn handle_event (& mut self , cx : & mut Cx , event : & Event , scope : & mut Scope) { let actions = cx . capture_actions (| cx | self . deref_widget . handle_event (cx , event , scope)) ; let my_btn = self . gbutton (id ! (my_btn)) ; let header = self . hello (id ! (header)) ; if let Some (_) = my_btn . clicked (& actions) { self . click_btn (cx) ; } } # [allow (unused_variables)] fn is_visible (& self) -> bool { self . visible } } impl LiveHook for Home { # [allow (unused_variables)] fn after_apply (& mut self , cx : & mut Cx , apply : & mut Apply , index : usize , nodes : & [LiveNode]) { self . deref_widget . after_apply (cx , apply , index , nodes) ; } fn after_new_from_doc (& mut self , cx : & mut Cx) { let deref_prop = HomeDeref :: default () ; self . set_num (cx , deref_prop . num) ; self . set_lbs (cx , deref_prop . lbs) ; } # [allow (unused_variables)] fn after_apply_from_doc (& mut self , cx : & mut Cx) { if ! self . visible { return ; } let c_ptr = self as * mut Home ; self . twb_poll . on_lbs_change = Some (Box :: new (move | cx , new_state | { unsafe { (* c_ptr) . lbs = new_state ; } })) ; } } # [derive (Default)] struct TwoWayBindingPoll { pub on_lbs_change : Option < Box < dyn Fn (& mut Cx , Vec < String >) > > , } impl Default for HomeDeref { fn default () -> Self { Self { num : 0 , lbs : vec ! ["1" . to_string () , "2" . to_string () , "3" . to_string ()] } } } pub struct HomeDeref { num : u32 , lbs : Vec < String > }