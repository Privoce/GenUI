use makepad_widgets :: * ; use gen_components :: * ; live_design ! { use link :: widgets :: * ; use link :: gen_components :: * ; use link :: shaders :: * ; pub Hello = { { Hello } } { item_ptr0 : < GView > { width : Fit , height : Fit , my_lb = < GLabel > { font_size : 16.0 , } } , align : { x : 0.5 , y : 0.5 , } , height : Fit , width : Fill , spacing : 12.0 , add_btn = < GButton > { } } } # [derive (Live , Widget)] pub struct Hello { # [deref] pub deref_widget : GView , # [live] my_text : String , # [live] pub list : Vec < String > , # [live] item_ptr0 : Option < LivePtr > , # [rust] twb_poll : TwoWayBindingPoll } impl Hello { fn get_my_text (& self) -> String { self . my_text . clone () } fn set_my_text (& mut self , cx : & mut Cx , value : String) -> () { self . my_text = value . clone () ; } fn get_list (& self) -> Vec < String > { self . list . clone () } fn set_list (& mut self , cx : & mut Cx , value : Vec < String >) -> () { self . sugar_for_list (cx , & value) ; self . list = value . clone () ; } fn sugar_for_list (& mut self , cx : & mut Cx , value : & Vec < String >) -> () { let len_list = self . list . len () ; if len_list > 0 && self . children . len () > 0usize { for _ in 0usize .. (0usize + len_list) { self . children . remove (0usize) ; } } for (index , item) in value . iter () . enumerate () { let item = item . clone () ; let widget_ref = WidgetRef :: new_from_ptr (cx , self . item_ptr0) ; let widget_target = widget_ref . as_gview () ; widget_target . glabel (id ! (my_lb)) . set_text (cx , item) ; self . children . insert (0usize + index , (LiveId (index as u64) , widget_ref)) ; } self . redraw (cx) ; } fn add (& self , actions : & Actions) -> Option < () > { if ! self . event_key { return None ; } if let HelloEvent :: Add = actions . find_widget_action (self . widget_uid ()) . cast () { Some (()) } else { None } } fn active_event < F > (& mut self , cx : & mut Cx , f : F) -> () where F : FnOnce (& mut Cx , WidgetUid , & HeapLiveIdPath) -> () { if self . event_key { self . scope_path . as_ref () . map (| path | { f (cx , self . widget_uid () , path) ; }) ; } } # [allow (unused_variables)] fn add_list (& mut self , cx : & mut Cx) { let mut list = self . get_list () ; list . push ("world" . to_string ()) ; self . set_list (cx , list) ; } } # [allow (unused)] impl HelloRef { pub fn get_my_text (& self) -> String { self . getter (| c_ref | c_ref . my_text . clone ()) } pub fn set_my_text (& self , cx : & mut Cx , value : String) -> () { self . setter (cx , | c_ref , cx | { c_ref . set_my_text (cx , value) ; }) ; } pub fn get_list (& self) -> Vec < String > { self . getter (| c_ref | c_ref . list . clone ()) } pub fn set_list (& self , cx : & mut Cx , value : Vec < String >) -> () { self . setter (cx , | c_ref , cx | { c_ref . set_list (cx , value) ; }) ; } fn setter < F > (& self , cx : & mut Cx , f : F) -> () where F : FnOnce (& mut std :: cell :: RefMut < '_ , Hello > , & mut Cx) , { if let Some (mut c_ref) = self . borrow_mut () { f (& mut c_ref , cx) ; } } fn getter < T , F > (& self , f : F) -> T where F : Fn (& std :: cell :: Ref < '_ , Hello >) -> T , T : Default , { if let Some (c_ref) = self . borrow () { f (& c_ref) } else { T :: default () } } pub fn add (& self , actions : & Actions) -> Option < () > { if let Some (c_ref) = self . borrow () { return c_ref . add (actions) ; } None } } impl Widget for Hello { # [allow (unused_variables)] fn draw_walk (& mut self , cx : & mut Cx2d , scope : & mut Scope , walk : Walk) -> DrawStep { self . deref_widget . draw_walk (cx , scope , walk) } # [allow (unused_variables)] fn handle_event (& mut self , cx : & mut Cx , event : & Event , scope : & mut Scope) { let actions = cx . capture_actions (| cx | self . deref_widget . handle_event (cx , event , scope)) ; let add_btn = self . gbutton (id ! (add_btn)) ; let lb_views = self . gview (id ! (lb_views)) ; if let Some (_) = add_btn . clicked (& actions) { self . add_list (cx) ; } } # [allow (unused_variables)] fn is_visible (& self) -> bool { self . visible } } impl LiveHook for Hello { # [allow (unused_variables)] fn after_apply (& mut self , cx : & mut Cx , apply : & mut Apply , index : usize , nodes : & [LiveNode]) { self . deref_widget . after_apply (cx , apply , index , nodes) ; } fn after_new_from_doc (& mut self , cx : & mut Cx) { let deref_prop = HelloDeref :: default () ; self . set_list (cx , deref_prop . list) ; } # [allow (unused_variables)] fn after_apply_from_doc (& mut self , cx : & mut Cx) { if ! self . visible { return ; } let c_ptr = self as * mut Hello ; self . twb_poll . on_list_change = Some (Box :: new (move | cx , new_state | { unsafe { (* c_ptr) . list = new_state ; } })) ; } } # [derive (Default)] struct TwoWayBindingPoll { pub on_list_change : Option < Box < dyn Fn (& mut Cx , Vec < String >) > > , } impl Default for HelloDeref { fn default () -> Self { Self { my_text : "Clicked: 0" . to_string () , list : vec ! ["Hello" . to_string ()] } } } pub struct HelloDeref { my_text : String , pub list : Vec < String > } # [derive (Debug , Clone)] # [derive (DefaultNone)] pub enum HelloEvent { Add , None }